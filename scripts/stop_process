#! /usr/bin/env python

import os
import rospy
import rostopic
import signal
import traceback
from roseus_resume.srv import RegisterInterruptionProcess
from roseus_resume.srv import RegisterInterruptionProcessResponse
from roseus_resume.srv import RegisterIntervention
from roseus_resume.srv import RegisterInterventionResponse
from std_msgs.msg import Empty
from threading import Thread


class StopSubscriber(object):
    def __init__(self, pid, ns):
        if ns.endswith('/'):
            ns = ns[:-1]
        self.pid = pid
        self.ns = ns
        self.interventions = []
        self.rate = rospy.Rate(10)
        self.stop_sub = rospy.Subscriber(self.ns + '/interrupt',
                                         Empty, self.stop)
        self.resume_sub = rospy.Subscriber(self.ns + '/resume',
                                           Empty, self.resume)
        # Use fixed namespace for 'register_intervention' service
        # Add pid suffix to allow multiple instances
        self.register_srv = rospy.Service(
            'roseus_resume/register_intervention_{}'.format(self.pid),
            RegisterIntervention,
            self.register)
        rospy.loginfo("Monitoring pid %d..." % self.pid)

    def register(self, msg):
        topic_name = rospy.resolve_name(msg.topic)
        message_type, name, _ = rostopic.get_topic_class(topic_name)
        if not message_type:
            rospy.logerr('No such topic: %s' % msg.topic)
            return RegisterInterventionResponse(False)
        try:
            sub = rospy.Subscriber(name, message_type, self.intervention)
            self.interventions.append(sub)
            return RegisterInterventionResponse(True)
        except Exception:
            traceback.print_exc()
            return RegisterInterventionResponse(False)

    def unregister(self):
        # Shutdown services and unregister topics
        self.register_srv.shutdown()
        self.stop_sub.unregister()
        self.resume_sub.unregister()
        for sub in self.interventions:
            sub.unregister()
        # Print message and finish thread
        rospy.logwarn("...Closing pid %d" % self.pid)
        exit()

    def _try_send_signal(self,sig):
        try:
            os.kill(self.pid, sig)
        except OSError:
            self.unregister()

    def intervention(self, msg=None):
        self._try_send_signal(signal.SIGUSR1)

    def stop(self, msg=None):
        self._try_send_signal(signal.SIGINT)

    def resume(self, msg=None):
        self._try_send_signal(signal.SIGCONT)

    def spin(self):
        while not rospy.is_shutdown():
            self._try_send_signal(0)
            self.rate.sleep()


class StopSubscriberThread(Thread):
    def __init__(self, pid, ns):
        Thread.__init__(self)
        self.stop_subscriber_instance = StopSubscriber(pid, ns)

    def run(self):
        self.stop_subscriber_instance.spin()


def register_interruption_process(req):
    res = RegisterInterruptionProcessResponse()
    ns = req.namespace or "intervention"
    pid = req.pid
    # Check if process exists
    try:
        os.kill(pid, 0)
    except OSError:
        rospy.logwarn("PID %d not found!" % pid)
        res.success = False
        return res
    thread = StopSubscriberThread(pid, ns)
    thread.start()

    res.success = True
    return res


def main():
    rospy.init_node("roseus_resume_stop_process")
    rospy.Service(
        "roseus_resume/register_interruption_process",
        RegisterInterruptionProcess,
        register_interruption_process)
    rospy.spin()


if __name__ == '__main__':
    main()
